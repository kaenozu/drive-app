// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: spots.sql

package dbgen

import (
	"context"
	"time"
)

const addFavorite = `-- name: AddFavorite :exec
INSERT OR IGNORE INTO favorites (user_id, spot_id) VALUES (?, ?)
`

type AddFavoriteParams struct {
	UserID string `json:"user_id"`
	SpotID int64  `json:"spot_id"`
}

func (q *Queries) AddFavorite(ctx context.Context, arg AddFavoriteParams) error {
	_, err := q.db.ExecContext(ctx, addFavorite, arg.UserID, arg.SpotID)
	return err
}

const createSpot = `-- name: CreateSpot :one
INSERT INTO spots (name, description, category, latitude, longitude, address, image_url, rating, created_by)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, name, description, category, latitude, longitude, address, image_url, rating, created_at, created_by
`

type CreateSpotParams struct {
	Name        string   `json:"name"`
	Description *string  `json:"description"`
	Category    string   `json:"category"`
	Latitude    float64  `json:"latitude"`
	Longitude   float64  `json:"longitude"`
	Address     *string  `json:"address"`
	ImageUrl    *string  `json:"image_url"`
	Rating      *float64 `json:"rating"`
	CreatedBy   *string  `json:"created_by"`
}

func (q *Queries) CreateSpot(ctx context.Context, arg CreateSpotParams) (Spot, error) {
	row := q.db.QueryRowContext(ctx, createSpot,
		arg.Name,
		arg.Description,
		arg.Category,
		arg.Latitude,
		arg.Longitude,
		arg.Address,
		arg.ImageUrl,
		arg.Rating,
		arg.CreatedBy,
	)
	var i Spot
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.Latitude,
		&i.Longitude,
		&i.Address,
		&i.ImageUrl,
		&i.Rating,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const deleteSpot = `-- name: DeleteSpot :exec
DELETE FROM spots WHERE id = ?
`

func (q *Queries) DeleteSpot(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSpot, id)
	return err
}

const getAllSpots = `-- name: GetAllSpots :many
SELECT id, name, description, category, latitude, longitude, address, image_url, rating, created_at, created_by FROM spots ORDER BY created_at DESC
`

func (q *Queries) GetAllSpots(ctx context.Context) ([]Spot, error) {
	rows, err := q.db.QueryContext(ctx, getAllSpots)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Spot{}
	for rows.Next() {
		var i Spot
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.Latitude,
			&i.Longitude,
			&i.Address,
			&i.ImageUrl,
			&i.Rating,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNearbySpots = `-- name: GetNearbySpots :many
SELECT id, name, description, category, latitude, longitude, address, image_url, rating, created_at, created_by,
    (6371 * acos(cos(radians(?)) * cos(radians(latitude)) * cos(radians(longitude) - radians(?)) + sin(radians(?)) * sin(radians(latitude)))) AS distance
FROM spots
ORDER BY distance
LIMIT ?
`

type GetNearbySpotsParams struct {
	RADIANS   interface{} `json:"radians"`
	RADIANS_2 interface{} `json:"radians_2"`
	RADIANS_3 interface{} `json:"radians_3"`
	Limit     int64       `json:"limit"`
}

type GetNearbySpotsRow struct {
	ID          int64       `json:"id"`
	Name        string      `json:"name"`
	Description *string     `json:"description"`
	Category    string      `json:"category"`
	Latitude    float64     `json:"latitude"`
	Longitude   float64     `json:"longitude"`
	Address     *string     `json:"address"`
	ImageUrl    *string     `json:"image_url"`
	Rating      *float64    `json:"rating"`
	CreatedAt   time.Time   `json:"created_at"`
	CreatedBy   *string     `json:"created_by"`
	Distance    interface{} `json:"distance"`
}

func (q *Queries) GetNearbySpots(ctx context.Context, arg GetNearbySpotsParams) ([]GetNearbySpotsRow, error) {
	rows, err := q.db.QueryContext(ctx, getNearbySpots,
		arg.RADIANS,
		arg.RADIANS_2,
		arg.RADIANS_3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNearbySpotsRow{}
	for rows.Next() {
		var i GetNearbySpotsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.Latitude,
			&i.Longitude,
			&i.Address,
			&i.ImageUrl,
			&i.Rating,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpotByID = `-- name: GetSpotByID :one
SELECT id, name, description, category, latitude, longitude, address, image_url, rating, created_at, created_by FROM spots WHERE id = ?
`

func (q *Queries) GetSpotByID(ctx context.Context, id int64) (Spot, error) {
	row := q.db.QueryRowContext(ctx, getSpotByID, id)
	var i Spot
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Category,
		&i.Latitude,
		&i.Longitude,
		&i.Address,
		&i.ImageUrl,
		&i.Rating,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getSpotsByCategory = `-- name: GetSpotsByCategory :many
SELECT id, name, description, category, latitude, longitude, address, image_url, rating, created_at, created_by FROM spots WHERE category = ? ORDER BY rating DESC
`

func (q *Queries) GetSpotsByCategory(ctx context.Context, category string) ([]Spot, error) {
	rows, err := q.db.QueryContext(ctx, getSpotsByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Spot{}
	for rows.Next() {
		var i Spot
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.Latitude,
			&i.Longitude,
			&i.Address,
			&i.ImageUrl,
			&i.Rating,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserFavorites = `-- name: GetUserFavorites :many
SELECT s.id, s.name, s.description, s.category, s.latitude, s.longitude, s.address, s.image_url, s.rating, s.created_at, s.created_by FROM spots s
JOIN favorites f ON s.id = f.spot_id
WHERE f.user_id = ?
ORDER BY f.created_at DESC
`

func (q *Queries) GetUserFavorites(ctx context.Context, userID string) ([]Spot, error) {
	rows, err := q.db.QueryContext(ctx, getUserFavorites, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Spot{}
	for rows.Next() {
		var i Spot
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Category,
			&i.Latitude,
			&i.Longitude,
			&i.Address,
			&i.ImageUrl,
			&i.Rating,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isFavorite = `-- name: IsFavorite :one
SELECT COUNT(*) FROM favorites WHERE user_id = ? AND spot_id = ?
`

type IsFavoriteParams struct {
	UserID string `json:"user_id"`
	SpotID int64  `json:"spot_id"`
}

func (q *Queries) IsFavorite(ctx context.Context, arg IsFavoriteParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, isFavorite, arg.UserID, arg.SpotID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const removeFavorite = `-- name: RemoveFavorite :exec
DELETE FROM favorites WHERE user_id = ? AND spot_id = ?
`

type RemoveFavoriteParams struct {
	UserID string `json:"user_id"`
	SpotID int64  `json:"spot_id"`
}

func (q *Queries) RemoveFavorite(ctx context.Context, arg RemoveFavoriteParams) error {
	_, err := q.db.ExecContext(ctx, removeFavorite, arg.UserID, arg.SpotID)
	return err
}
