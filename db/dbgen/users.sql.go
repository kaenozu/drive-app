// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package dbgen

import (
	"context"
	"time"
)

const addRecommendationHistory = `-- name: AddRecommendationHistory :one
INSERT INTO recommendation_history (user_id, spot_id, recommended_at, was_accepted)
VALUES (?, ?, CURRENT_TIMESTAMP, ?)
RETURNING id, user_id, spot_id, recommended_at, was_accepted
`

type AddRecommendationHistoryParams struct {
	UserID      string `json:"user_id"`
	SpotID      int64  `json:"spot_id"`
	WasAccepted *bool  `json:"was_accepted"`
}

func (q *Queries) AddRecommendationHistory(ctx context.Context, arg AddRecommendationHistoryParams) (RecommendationHistory, error) {
	row := q.db.QueryRowContext(ctx, addRecommendationHistory, arg.UserID, arg.SpotID, arg.WasAccepted)
	var i RecommendationHistory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SpotID,
		&i.RecommendedAt,
		&i.WasAccepted,
	)
	return i, err
}

const addVisitHistory = `-- name: AddVisitHistory :one
INSERT INTO visit_history (user_id, spot_id, visited_at, rating, comment)
VALUES (?, ?, CURRENT_TIMESTAMP, ?, ?)
RETURNING id, user_id, spot_id, visited_at, rating, comment
`

type AddVisitHistoryParams struct {
	UserID  string  `json:"user_id"`
	SpotID  int64   `json:"spot_id"`
	Rating  *int64  `json:"rating"`
	Comment *string `json:"comment"`
}

func (q *Queries) AddVisitHistory(ctx context.Context, arg AddVisitHistoryParams) (VisitHistory, error) {
	row := q.db.QueryRowContext(ctx, addVisitHistory,
		arg.UserID,
		arg.SpotID,
		arg.Rating,
		arg.Comment,
	)
	var i VisitHistory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SpotID,
		&i.VisitedAt,
		&i.Rating,
		&i.Comment,
	)
	return i, err
}

const getOrCreateUser = `-- name: GetOrCreateUser :one
INSERT INTO users (id, created_at, last_seen)
VALUES (?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT(id) DO UPDATE SET last_seen = CURRENT_TIMESTAMP
RETURNING id, created_at, last_seen
`

func (q *Queries) GetOrCreateUser(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getOrCreateUser, id)
	var i User
	err := row.Scan(&i.ID, &i.CreatedAt, &i.LastSeen)
	return i, err
}

const getRecentRecommendations = `-- name: GetRecentRecommendations :many
SELECT spot_id FROM recommendation_history
WHERE user_id = ? AND recommended_at > datetime('now', '-7 days')
ORDER BY recommended_at DESC
`

func (q *Queries) GetRecentRecommendations(ctx context.Context, userID string) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, getRecentRecommendations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var spot_id int64
		if err := rows.Scan(&spot_id); err != nil {
			return nil, err
		}
		items = append(items, spot_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPreferences = `-- name: GetUserPreferences :one
SELECT id, user_id, preferred_categories, preferred_distance_km, preferred_time_hours, avoid_categories, updated_at FROM user_preferences WHERE user_id = ?
`

func (q *Queries) GetUserPreferences(ctx context.Context, userID string) (UserPreference, error) {
	row := q.db.QueryRowContext(ctx, getUserPreferences, userID)
	var i UserPreference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PreferredCategories,
		&i.PreferredDistanceKm,
		&i.PreferredTimeHours,
		&i.AvoidCategories,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserStats = `-- name: GetUserStats :one
SELECT 
    COUNT(DISTINCT vh.spot_id) as total_visits,
    AVG(vh.rating) as avg_rating,
    (
        SELECT category FROM (
            SELECT s.category, COUNT(*) as cnt
            FROM visit_history vh2
            JOIN spots s ON vh2.spot_id = s.id
            WHERE vh2.user_id = vh.user_id AND vh2.rating >= 4
            GROUP BY s.category
            ORDER BY cnt DESC
            LIMIT 1
        )
    ) as favorite_category
FROM visit_history vh
WHERE vh.user_id = ?
`

type GetUserStatsRow struct {
	TotalVisits      int64    `json:"total_visits"`
	AvgRating        *float64 `json:"avg_rating"`
	FavoriteCategory string   `json:"favorite_category"`
}

func (q *Queries) GetUserStats(ctx context.Context, userID string) (GetUserStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getUserStats, userID)
	var i GetUserStatsRow
	err := row.Scan(&i.TotalVisits, &i.AvgRating, &i.FavoriteCategory)
	return i, err
}

const getUserVisitHistory = `-- name: GetUserVisitHistory :many
SELECT vh.id, vh.user_id, vh.spot_id, vh.visited_at, vh.rating, vh.comment, s.name as spot_name, s.category as spot_category
FROM visit_history vh
JOIN spots s ON vh.spot_id = s.id
WHERE vh.user_id = ?
ORDER BY vh.visited_at DESC
LIMIT ?
`

type GetUserVisitHistoryParams struct {
	UserID string `json:"user_id"`
	Limit  int64  `json:"limit"`
}

type GetUserVisitHistoryRow struct {
	ID           int64     `json:"id"`
	UserID       string    `json:"user_id"`
	SpotID       int64     `json:"spot_id"`
	VisitedAt    time.Time `json:"visited_at"`
	Rating       *int64    `json:"rating"`
	Comment      *string   `json:"comment"`
	SpotName     string    `json:"spot_name"`
	SpotCategory string    `json:"spot_category"`
}

func (q *Queries) GetUserVisitHistory(ctx context.Context, arg GetUserVisitHistoryParams) ([]GetUserVisitHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserVisitHistory, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserVisitHistoryRow{}
	for rows.Next() {
		var i GetUserVisitHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SpotID,
			&i.VisitedAt,
			&i.Rating,
			&i.Comment,
			&i.SpotName,
			&i.SpotCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserVisitedSpotIDs = `-- name: GetUserVisitedSpotIDs :many
SELECT DISTINCT spot_id FROM visit_history WHERE user_id = ?
`

func (q *Queries) GetUserVisitedSpotIDs(ctx context.Context, userID string) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, getUserVisitedSpotIDs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var spot_id int64
		if err := rows.Scan(&spot_id); err != nil {
			return nil, err
		}
		items = append(items, spot_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecommendationAccepted = `-- name: UpdateRecommendationAccepted :exec
UPDATE recommendation_history SET was_accepted = TRUE
WHERE user_id = ? AND spot_id = ?
`

type UpdateRecommendationAcceptedParams struct {
	UserID string `json:"user_id"`
	SpotID int64  `json:"spot_id"`
}

func (q *Queries) UpdateRecommendationAccepted(ctx context.Context, arg UpdateRecommendationAcceptedParams) error {
	_, err := q.db.ExecContext(ctx, updateRecommendationAccepted, arg.UserID, arg.SpotID)
	return err
}

const upsertUserPreferences = `-- name: UpsertUserPreferences :one
INSERT INTO user_preferences (user_id, preferred_categories, preferred_distance_km, preferred_time_hours, avoid_categories, updated_at)
VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(user_id) DO UPDATE SET
    preferred_categories = excluded.preferred_categories,
    preferred_distance_km = excluded.preferred_distance_km,
    preferred_time_hours = excluded.preferred_time_hours,
    avoid_categories = excluded.avoid_categories,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, user_id, preferred_categories, preferred_distance_km, preferred_time_hours, avoid_categories, updated_at
`

type UpsertUserPreferencesParams struct {
	UserID              string   `json:"user_id"`
	PreferredCategories *string  `json:"preferred_categories"`
	PreferredDistanceKm *float64 `json:"preferred_distance_km"`
	PreferredTimeHours  *float64 `json:"preferred_time_hours"`
	AvoidCategories     *string  `json:"avoid_categories"`
}

func (q *Queries) UpsertUserPreferences(ctx context.Context, arg UpsertUserPreferencesParams) (UserPreference, error) {
	row := q.db.QueryRowContext(ctx, upsertUserPreferences,
		arg.UserID,
		arg.PreferredCategories,
		arg.PreferredDistanceKm,
		arg.PreferredTimeHours,
		arg.AvoidCategories,
	)
	var i UserPreference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PreferredCategories,
		&i.PreferredDistanceKm,
		&i.PreferredTimeHours,
		&i.AvoidCategories,
		&i.UpdatedAt,
	)
	return i, err
}
